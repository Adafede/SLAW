table(table(anotated_pl[,"pcgroup"]))
table(table(annotated_pl[,"pcgroup"]))
annotated_pl$pcgroup
ttab <-table(annotated_pl[,"pcgroup"])
which(ttab>700)
ttab["90"]
ttab
which(ttab>100)
dim(annotated_pl)
annotated_pl[,"pcgroup"]==91
which(annotated_pl[,"pcgroup"]==91)
annotated_pl[which(annotated_pl[,"pcgroup"]==91),]
lementation of the LIPO algoirthm
test <- function(x){
-(5*sin(10*x)+2*x**2)
}
xseq <- seq(-2,2,length=100)
plot(xseq,test(xseq),type="l")
constraint <- list(x=c(-5,5))
###The maximum is always between 2 points, to find it we just have to consider
##every pair of points
#estimates th upper bound
upperBound <- function(x,points,val_points,k){
if(is.list(points)){
points <- t(sapply(points,function(x){do.call(c,x)}))
}
##We first find the two closest points from x
sq_part <- sweep(points,2,x,FUN = "-")
if(length(k)==1){
k <- matrix(k**2,nrow=1,ncol=1)
}else{
k <- diag(k**2)
}
val_sq <- apply(sq_part,2,function(x,k){
x <- as.matrix(x)
sqrt(x %*% k %*% t(x))
},k=k)
message("points")
print(points)
message("val_sq")
print(val_sq)
message("val_points")
print(val_points)
if(length(val_points)!=length(val_sq)) browser()
tval <- val_points+val_sq
###This return the value of the upper bound
min(tval)
}
findingLipschitzConstant <- function(points,val_fun){
mpoints <- lapply(points,function(x){do.call(c,x)})
###We order th epoint
mpoints <-  as.matrix(do.call(rbind,mpoints))
if(is.list(mpoints)) browser()
dim_order <- apply(mpoints,2,order)
##We now xompute all the derivative
k <- rep(NA,ncol(mpoints))
for(i in 1:ncol(mpoints)){
# print(dim_order[,i])
# print(mpoints)
dy <- diff(val_fun[dim_order[,i]])
dx <- diff(mpoints[dim_order[,i],i])
message("dx")
print(dx)
message("dy")
print(dy)
est_deriv <- dy/dx
k[i] <- max(abs(est_deriv))
}
message("k",k)
return(k)
}
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=100)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
npoint <- optim(par = list(x=0),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]]
n_bound <-upperBound(npoint,vpoints,val_points,k)
plot(xseq,yseq,type="l",main=paste("iter",count))
points(do.call(c,vpoints),val_points,pch=16,col="red")
###We line th eupper bound
lines(xseq,sapply(xseq,upperBound,points=vpoints,
val_points=val_points,k=k),col="green")
browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val)
###WEe recalculate the lipschitz constant
}
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
vpoints[[mval]]
}
LIPO(list(x=c(-5,5)),test,max_call=50)
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=100)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
npoint <- optim(par = list(x=0),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]]
n_bound <-upperBound(npoint,vpoints,val_points,k)
plot(xseq,yseq,type="l",main=paste("iter",count))
points(do.call(c,vpoints),val_points,pch=16,col="red")
###We line th eupper bound
lines(xseq,sapply(xseq,upperBound,points=vpoints,
val_points=val_points,k=k),col="green")
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val)
###WEe recalculate the lipschitz constant
}
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
vpoints[[mval]]
}
LIPO(list(x=c(-5,5)),test,max_call=50)
###A test implementation of the LIPO algoirthm
test <- function(x){
-(5*sin(10*x)+2*x**2)
}
xseq <- seq(-2,2,length=100)
plot(xseq,test(xseq),type="l")
constraint <- list(x=c(-5,5))
###The maximum is always between 2 points, to find it we just have to consider
##every pair of points
#estimates th upper bound
upperBound <- function(x,points,val_points,k){
if(is.list(points)){
points <- t(sapply(points,function(x){do.call(c,x)}))
}
##We first find the two closest points from x
sq_part <- sweep(points,2,x,FUN = "-")
if(length(k)==1){
k <- matrix(k**2,nrow=1,ncol=1)
}else{
k <- diag(k**2)
}
val_sq <- apply(sq_part,2,function(x,k){
x <- as.matrix(x)
sqrt(x %*% k %*% t(x))
},k=k)
# message("points")
# print(points)
# message("val_sq")
# print(val_sq)
# message("val_points")
# print(val_points)
if(length(val_points)!=length(val_sq)) browser()
tval <- val_points+val_sq
###This return the value of the upper bound
min(tval)
}
findingLipschitzConstant <- function(points,val_fun){
mpoints <- lapply(points,function(x){do.call(c,x)})
###We order th epoint
mpoints <-  as.matrix(do.call(rbind,mpoints))
if(is.list(mpoints)) browser()
dim_order <- apply(mpoints,2,order)
##We now xompute all the derivative
k <- rep(NA,ncol(mpoints))
for(i in 1:ncol(mpoints)){
# print(dim_order[,i])
# print(mpoints)
dy <- diff(val_fun[dim_order[,i]])
dx <- diff(mpoints[dim_order[,i],i])
# message("dx")
# print(dx)
# message("dy")
# print(dy)
est_deriv <- dy/dx
k[i] <- max(abs(est_deriv))
}
# message("k",k)
return(k)
}
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=1000)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
###The optim is odne on the full interval every time
npoint <- unname(optim(par = list(x=runif(1,constraint[[1]][1],
constraint[[1]][2])),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]])
n_bound <-upperBound(npoint,vpoints,val_points,k)
plot(xseq,yseq,type="l",main=paste("iter",count))
points(do.call(c,vpoints),val_points,pch=16,col="red")
###We line th eupper bound
lines(xseq,sapply(xseq,upperBound,points=vpoints,
val_points=val_points,k=k),col="green")
# if(count==1) browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
# if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val_points)
# if(is.na(k)) browser()
###WEe recalculate the lipschitz constant
# }
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
vpoints[[mval]]
}
LIPO(list(x=c(-5,5)),test,max_call=20)
abline(v=0.77)
LIPO(list(x=c(-5,5)),test,max_call=20)
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=1000)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
###The optim is odne on the full interval every time
npoint <- unname(optim(par = list(x=runif(1,constraint[[1]][1],
constraint[[1]][2])),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]])
n_bound <-upperBound(npoint,vpoints,val_points,k)
# plot(xseq,yseq,type="l",main=paste("iter",count))
# points(do.call(c,vpoints),val_points,pch=16,col="red")
# ###We line th eupper bound
# lines(xseq,sapply(xseq,upperBound,points=vpoints,
#                   val_points=val_points,k=k),col="green")
# if(count==1) browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
# if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val_points)
# if(is.na(k)) browser()
###WEe recalculate the lipschitz constant
# }
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
vpoints[[mval]]
}
LIPO(list(x=c(-5,5)),test,max_call=20)
57+44
abline(h=1.24)
abline(v=1.24)
abline(v=-0.19)
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=1000)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
###The optim is odne on the full interval every time
npoint <- unname(optim(par = list(x=runif(1,constraint[[1]][1],
constraint[[1]][2])),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]])
n_bound <-upperBound(npoint,vpoints,val_points,k)
# plot(xseq,yseq,type="l",main=paste("iter",count))
# points(do.call(c,vpoints),val_points,pch=16,col="red")
# ###We line th eupper bound
# lines(xseq,sapply(xseq,upperBound,points=vpoints,
#                   val_points=val_points,k=k),col="green")
# if(count==1) browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
# if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val_points)
# if(is.na(k)) browser()
###WEe recalculate the lipschitz constant
# }
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
return(vpoints[[mval]],points,val_points,k)
}
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=1000)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
###The optim is odne on the full interval every time
npoint <- unname(optim(par = list(x=runif(1,constraint[[1]][1],
constraint[[1]][2])),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]])
n_bound <-upperBound(npoint,vpoints,val_points,k)
# plot(xseq,yseq,type="l",main=paste("iter",count))
# points(do.call(c,vpoints),val_points,pch=16,col="red")
# ###We line th eupper bound
# lines(xseq,sapply(xseq,upperBound,points=vpoints,
#                   val_points=val_points,k=k),col="green")
# if(count==1) browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
# if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val_points)
# if(is.na(k)) browser()
###WEe recalculate the lipschitz constant
# }
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
return(vpoints[[mval]],vpoints,val_points,k)
}
LIPO(list(x=c(-5,5)),test,max_call=20)
##Firstr LIPO fo rthe test function only
LIPO <- function(constraint,func,max_call=50){
count <- 0
###We first sample 4 points randonl
initial_values <- sapply(constraint,function(x){
x[1]+(x[2]-x[1])*seq(0,1,length=6)[2:5]
})
xseq <- seq(-5,5,length=1000)
yseq <- sapply(xseq,func)
##We get the value of the function at thos points
vpoints <- apply(initial_values,1,function(x){
temp<-as.list(x)
names(temp)<-names(x)
temp})
val_points <- sapply(vpoints,function(x,fun){do.call(fun,x)},fun=func)
###We compute the order for the different
##We initalize the lipischitz term with the maximum initialized slope
k <- findingLipschitzConstant(vpoints,val_points)
###A very dirty implementa
while(count<max_call){
###The optim is odne on the full interval every time
npoint <- unname(optim(par = list(x=runif(1,constraint[[1]][1],
constraint[[1]][2])),fn=upperBound,method="L-BFGS-B",
lower=c(-5),upper=5,
points=matrix(vpoints,ncol=1),
val_points=val_points,k=k,
control=list(fnscale=-1))[[1]])
n_bound <-upperBound(npoint,vpoints,val_points,k)
# plot(xseq,yseq,type="l",main=paste("iter",count))
# points(do.call(c,vpoints),val_points,pch=16,col="red")
# ###We line th eupper bound
# lines(xseq,sapply(xseq,upperBound,points=vpoints,
#                   val_points=val_points,k=k),col="green")
# if(count==1) browser()
n_val <- func(npoint)
vpoints[[length(vpoints)+1]] <- list(x=npoint)
val_points <- c(val_points,n_val)
# if(n_val>n_bound){
k <- findingLipschitzConstant(vpoints,val_points)
# if(is.na(k)) browser()
###WEe recalculate the lipschitz constant
# }
##We check if the value is supposedly
count <- count+1
}
###Return the point hte maximu mvalue
mval <- which.max(val_points)
return(list(vpoints[[mval]],vpoints,val_points,k))
}
LIPO(list(x=c(-5,5)),test,max_call=20)
7/47-26
-25.85/2
7/47-5.3
-5.15/2
abline(v=-2.575)
test <- function(x,y,k){
return(5*(sin(10*(x+y))+2*(x+y)**2)+k)
}
x <- seq(-1.5,3.5,length.out=100)
y <- seq(-2.5,2.5,length.out=100)
z <- outer(x,y,FUN = test,k=2)
persp(x,y,z, col='blue')
abline(v=-1.25)
abline(v=1.25,col="red")
xseq
xseq <- seq(-5,5,length=500)
plot(xseq,test(xseq))
test <- function(x){
-(5*sin(10*x)+2*x**2)
}
plot(xseq,test(xseq))
plot(xseq,test(xseq),type="l")
abline(v=-1.25)
test(1.25)
test(-1.25)
test(3.75)
test <- function(x){
-(5*sin(10*x)+2*(x**2))
}
test(3.75)
3.75**2
abline(v=0.16,col="purple")
abline(v=-0.16,col="purple")
persp(x,y,z, col='blue')
